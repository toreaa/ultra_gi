# Story 4.2: Bruk produkter fra skafferi

## Status
**Draft**

## Story
**As a** user, **I want** the nutrition plan to use products from my skafferi, **so that** the plan is realistic and practical for me.

## Acceptance Criteria
1. Appen genererer forslag basert på tilgjengelige produkter
2. Algoritme (MVP - enkel greedy): Sorter produkter etter "passer best", Velg kombinasjon som treffer ~90-110% av mål, Prioriter færre produkter (1-3)
3. Foreslått plan vises som liste: Produktnavn, Antall, Total karbs, Prosent av mål
4. Timing-forslag (auto-generert): Del opp inntak jevnt over økten
5. Bruker kan: Akseptere forslag, Manuell tilpasning (endre antall, legge til/fjerne, justere timing), Live oppdatering av total

## Tasks / Subtasks
- [ ] Create `src/services/fuelPlanner.ts`
- [ ] Implement `generateFuelPlan(targetCarbs, duration, availableProducts)`
- [ ] Implement greedy algorithm (sort by carbs descending, select best fit)
- [ ] Generate timing suggestions: `Array.from({length: qty}, (_, i) => Math.round((i + 1) * interval))`
- [ ] Create `src/components/fuel/FuelSelector.tsx` UI
- [ ] Allow manual adjustments (quantity, add/remove products)
- [ ] Real-time update total carbs and % of target
- [ ] Handle edge case: empty skafferi → show error

## Dev Notes
**Algorithm [Source: architecture/prd/epic-4-planning.md]:**
```typescript
export function generateFuelPlan(
  targetCarbs: number,
  durationMinutes: number,
  availableProducts: FuelProduct[]
): FuelPlan {
  const plan: FuelPlanItem[] = [];
  let remainingCarbs = targetCarbs;

  const sorted = [...availableProducts].sort((a, b) => b.carbs_per_serving - a.carbs_per_serving);

  for (const product of sorted) {
    if (remainingCarbs <= 0) break;
    const quantity = Math.min(Math.ceil(remainingCarbs / product.carbs_per_serving), 5);
    
    plan.push({
      fuel_product_id: product.id,
      product_name: product.name,
      quantity,
      timing_minutes: generateTiming(durationMinutes, quantity),
      carbs_total: product.carbs_per_serving * quantity,
    });

    remainingCarbs -= product.carbs_per_serving * quantity;
  }

  return plan;
}

function generateTiming(duration: number, quantity: number): number[] {
  const interval = duration / (quantity + 1);
  return Array.from({ length: quantity }, (_, i) => Math.round((i + 1) * interval));
}
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story | Bob (SM) |

## Dev Agent Record
*To be filled*

## QA Results
*To be filled*
